<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Aplicaciones interactivas con Shiny</title>
    <meta charset="utf-8" />
    <meta name="date" content="2023-06-10" />
    <script src="clase_shiny_files/header-attrs-2.18/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">


class: center, middle

.linea-superior[]
.linea-inferior[]

&lt;img src="imagenes/logo_portada2.png" width="200" /&gt;

## Capacitación en R y herramientas de productividad - Shiny

## Proyecto Estratégico Metodologías y Ciencia de Datos para la Producción Estadística

### Junio 2023








---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Pero antes que todo!!!

Trabajaremos con los siguientes paquetes, les invitamos a instalarlos para seguir la clase:


```r
install.packages(c("shiny","guaguas","dplyr","ggplot2","calidad","survey","writexl"))

library("shiny")
library("guaguas")
library("dplyr")
library("ggplot2")
library("calidad")
library("survey")
library("writexl")
```

.center[&lt;img src="imagenes/brent-rambo-not-bad.gif" width= "400"/&gt;]

---


background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%


# Estructura del taller

**Contenidos de la clase**

- I - Motivación


--


- II - Principales características de una Shiny App

--

- III - ¡A construir una Shiny App!

--

- IV - Ejemplos de Shiny Apps construidas en el INE.

--

- V - Tips y referencias
      
      
--


**Objetivos de la clase:**

-  Capacitar en la construcción de una Shiny App.



---

class: inverse, center, middle

# I. Motivación

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# ¿Que es Shiny?

- Es un paquete de R, que simplifica la construcción de plataformas interactivas para personas que vienen de disciplinas lejanas a la programación web o desde la ciencia y analítica de datos.

--
  
- Shiny es un **"wrapper"** de html, css y JavaScript, los principales lenguajes para construir aplicaciones web.

--

¿Porque utilizar Shiny?

*Iteractividad!!!*  -&gt; clickear, ingresar datos, cambiar parametros.

--

*¿Para qué?*

  - Resultados de análisis de una investigación. (shiny empresas)
  - Disponibilizar alguna herramienta. (paquete de calidad)
  - Evaluar el avance de una investigación, (esto nos ahorra mucho código)
  - Simplemente automatizar un proceso tedioso
  
--

*Usuarios finales*
  - Usuarios que no sepan programar
  - nosotros mismos!

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Shiny para aplicaciones web

Se podría generalizar que existen 3 tipos de aplicaciones web.

--

- Páginas de contacto, solo informativa sin interactividad, usualmente construidas con HTML y CSS en R tenemos paquetes como: rmarkdown, quarto, hugo, bookdown.

--
 
- Plataformas que permiten al usuario realizar acciones desde: seleccionar, mover, filtrar, cargar, entre otro: (html, css, js), acá Shiny es útil.
 
--

- Plataformas con bases de datos, permiten tener varios usuarios con acceso, los datos son consultados por querys: (html, css, js, sql). Acá Shiny puede hacer algo, pero necesita ayuda.

--

.center[


&lt;img src="imagenes/front_back.png" width="400" /&gt;


]

---

class: inverse, center, middle

# II. Principales características de Shiny App

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Principales características de Shiny App

Estos son los componentes principales de una Shiny App

-ui

-server

-shinyApp(ui,serve)

-inputs

-outputs

-¿reactividad? reactive({}) y observeEvent({})

-acctionButton

-isolate

-downloadHandler

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Principales características de Shiny App

Componentes básicos de una Shiny App

--

- **ui**: *(user interface)* Este objeto controla el diseño y la apariencia de la aplicación.

--

- **server**: Esta función contiene las instrucciones que el R necesita para construir la aplicación

--

- **shinyApp**(ui,serve): Corre la app uniendo los dos elementos anteriores.

--


```r
library(shiny)

ui &lt;- fluidPage(
  
)

server &lt;- function(input, output, session) {  
  
}

shinyApp(ui, server)
```

--

**¿Como creamos un proyeto de Shiny App?**

--

Veamos el código!!!...     &lt;svg viewBox="0 0 640 512" style="height:1em;position:relative;display:inline-block;top:.1em;" xmlns="http://www.w3.org/2000/svg"&gt;  &lt;path d="M624 416H381.54c-.74 19.81-14.71 32-32.74 32H288c-18.69 0-33.02-17.47-32.77-32H16c-8.8 0-16 7.2-16 16v16c0 35.2 28.8 64 64 64h512c35.2 0 64-28.8 64-64v-16c0-8.8-7.2-16-16-16zM576 48c0-26.4-21.6-48-48-48H112C85.6 0 64 21.6 64 48v336h512V48zm-64 272H128V64h384v256z"&gt;&lt;/path&gt;&lt;/svg&gt;



---

class: inverse, center, middle

# III. ¡A construir una Shiny App!

---

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Como construi la ui

.pull-left[

**sidebarLayout()**


```r
ui &lt;- fluidPage(
  titlePanel("Central limit theorem"),
  sidebarLayout(
    sidebarPanel(
      numericInput("m", "Number of samples:", 2, min = 1, max = 100)
    ),
    mainPanel(
      plotOutput("hist")
    )
  )
)

##### * este código es solo de ejemplo, no está completo para generar una app
```

**tabsetPanel()**


```r
ui &lt;- fluidPage(
  tabsetPanel(
    tabPanel("Import data", 
      fileInput("file", "Data", buttonLabel = "Upload..."),
      textInput("delim", "Delimiter (leave blank to guess)", ""),
      numericInput("skip", "Rows to skip", 0, min = 0),
      numericInput("rows", "Rows to preview", 10, min = 1)
    ),
    tabPanel("Set parameters"),
    tabPanel("Visualise results")
  )
)

##### * este código es solo de ejemplo, no está completo para generar una app
```

**navbarPage()**


```r
ui &lt;- fluidPage(
  navbarPage("App Title",
             tabPanel("Plot"),
             tabPanel("Summary"),
             tabPanel("Table")
  )
)

##### * este código es solo de ejemplo, no está completo para generar una app
```


]

.pull-right[

<br/>

.right[&lt;img src="imagenes/sidebar.png" width= "400"/&gt;]

<br/>
<br/>
<br/>


.right[&lt;img src="imagenes/tabset.png" width= "400"/&gt;]

<br/>
<br/>
<br/>
<br/>
<br/>


.right[&lt;img src="imagenes/navbarpage.png" width= "400"/&gt;]

]

--


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Veamos como construir la ui

Shiny posee funciones que nos permiten agregar contenidos para mejorar nuestra ui, estas funciones son "**wrapper**" de html.

.center[&lt;img src="imagenes/shiny_html1.png" width= "700"/&gt;]

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Veamos como construir la ui

Shiny posee funciones que nos permiten agregar contenidos para mejorar nuestra ui, estas funciones son "**wrapper**" de html.

.center[&lt;img src="imagenes/shiny_html2.png" width= "700"/&gt;]

---

class: inverse, center, middle

# Pero... ¿Como el usuario interactua con la ui?

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Con widgets!

Los widgets son las "dispositivos" que la app nos ofrece para interactuar.

Se dividen entre **INPUTS** y **OUTPUTS**, ya que como sus nombres lo indican es donde ingresamos parametros y donde recibimos los productos procesados.


.center[&lt;img src="imagenes/input-output.gif" width= "500"/&gt;]



---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Inputs 

Son funciones especiales que permiten al usuario ingresar parametros o información a la app, es por ello que van desde la **ui**. al **server**.

Todos poseen almenos dos parametros básicos:

--

**inputId:** Es el nombre que le damos al input en particular, para luego poder acceder.

--

**label:** Es la etiqueta que el usuario lee sobre el input.

--


Todos los inputs de una app son almacenados dentro de una lista llamada: *input*, para acceder a ellos debemos buscarlos en esa lista, tal y como se hace en **R**:


```r
ui &lt;- fluidPage(
  numericInput("variable1","Variable 1",value = 30)
)

##### * este código es solo de ejemplo, no está completo para generar una app
```

.size_style[input$].color_style[variable1]

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Inputs 

Todos los inputs reciben un tipo de dato en particular, sea  **texto**. **numérico**, **factores** o **fechas**, entre otros,

Algunos de los inputs son los siguientes:

<br/>

.center[&lt;img src="imagenes/inputs.png" width= "700"/&gt;] [*](https://www.paulamoraga.com/book-geospatial/sec-shiny.html)

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Outputs 

Los outputs son los resultados que la app nos devuelve, pueden ser gráficos, imagenes, tablas, texto e incluso mapas, existe una gran diversidad de visualizaciones o resultados a obtener, dependiendo del interes del usuario.

Los outputs viajan desde el **server** hacia la **ui**.

Los outputs dependen de procesamientos que pasan en la función **server** de la aplicación, donde ocurre la magia y se combinan los elementos que el usuario ha ido ingresando.

Al igual que los inputs los outputs son almacenados dentro de una lista llamada: *output*, para acceder a ellos debemos buscarlos en esa lista, tal y como se hace en **R**:


```r
server &lt;- function(input, output, session) {

output$frecuencia_guaguas &lt;- renderPlot({
    grafico
  })
}

##### * este código es solo de ejemplo, no está completo para generar una app
```

.size_style[output$].color_style[plot1]

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Outputs

Algunos outputs son:

<br/>


.center[&lt;img src="imagenes/outputs.png" width= "600"/&gt;] [*](https://www.paulamoraga.com/book-geospatial/sec-shiny.html)

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Construyendo una app que busca nombres

Vamos al código!!!...     &lt;svg viewBox="0 0 640 512" style="height:1em;position:relative;display:inline-block;top:.1em;" xmlns="http://www.w3.org/2000/svg"&gt;  &lt;path d="M624 416H381.54c-.74 19.81-14.71 32-32.74 32H288c-18.69 0-33.02-17.47-32.77-32H16c-8.8 0-16 7.2-16 16v16c0 35.2 28.8 64 64 64h512c35.2 0 64-28.8 64-64v-16c0-8.8-7.2-16-16-16zM576 48c0-26.4-21.6-48-48-48H112C85.6 0 64 21.6 64 48v336h512V48zm-64 272H128V64h384v256z"&gt;&lt;/path&gt;&lt;/svg&gt;


```r
library(shiny)
library(guaguas)
library(dplyr)
library(ggplot2)

datos &lt;- guaguas %&gt;% filter(n &gt;= 100)

ui &lt;- fluidPage(
  titlePanel("Buscando nombres"),
  sidebarLayout(
    sidebarPanel(h3("Inputs"),
                 selectInput(inputId = "nombre",
                             label = "Nombres",
                             choices = unique(datos$nombre))
    ),
    mainPanel(h3("Outputs"),
              plotlyOutput(outputId = "frecuencia_guaguas")
    )
  )
)

server &lt;- function(input, output, session) {

     grafico &lt;-  datos %&gt;%
        filter(nombre == input$nombre) %&gt;%
        ggplot(aes(anio,n)) +
        geom_line()
     
output$frecuencia_guaguas &lt;- renderPlot({
    grafico
  })
  
}
shinyApp(ui, server)
```

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# ¿Que es la reactividad?

Este es el error mas típico aprendiendo Shiny:

**"Caused by error in `input$nombre`:
! Can't access reactive value 'nombre' outside of reactive consumer.
ℹ Do you need to wrap inside reactive() or observe()?"**

--

En español:

**"Provocado por error en input$nombre: ! No se puede acceder al valor reactivo 'nombre' fuera del consumidor reactivo.  
¿Necesita envolver dentro de reactivo() u observar()?"**

--

La **reactividad**, es el mecanismo por el cual Shiny determina que código en el **server**, tiene que cambiar cuando el usuario realiza alguna acción. 

Podríamos decir que son objetos de R que pueden cambiar en base al usuario (casi siempre) y que por ello deben tratarse de manera especial, "envueltos" en funciones reactivas u observadoras (ya lo veremos).

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Construyendo una app que busca nombres

.size_style[Ahora si!]


```r
library(shiny)
library(guaguas)
library(dplyr)
library(ggplot2)

datos &lt;- guaguas %&gt;% filter(n &gt;= 100)

ui &lt;- fluidPage(
  titlePanel("Buscando nombres"),
      sidebarLayout(
        sidebarPanel(h3("Inputs"),
                    selectInput(inputId = "nombre",
                    label = "Nombres",
                    choices = unique(datos$nombre))
             ),
        mainPanel(h3("Outputs"),
                  plotOutput(outputId = "frecuencia_guaguas")
                   )
          )
)



server &lt;- function(input, output, session) {

grafico &lt;- reactive({datos %&gt;%
      filter(nombre == input$nombre) %&gt;%
      ggplot(aes(anio,n)) +
      geom_line()
})
  
  
  output$frecuencia_guaguas &lt;- renderPlot({
grafico()
  })

}

shinyApp(ui, server)
```


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# ¿Que es la reactividad?

¿Y si queremos agregar mas nombres? o ¿Si queremos controlar cuando se genera el gráfico?

--

Como ya se mencionó existen dos grupo de funciones que reciben a los objetos reactivos, las funciones **reactivas** y las funciones que **observan**.

--

A diferencia de las funciones reactivas, las funciones que observan permiten que pasen acciones secundarias, pero no generan un objeto nuevo.

--

En el siguente ejemplo podemos ver como la función **observeEvent({})** recibe como argumento el input *input$generar_gráfico*, solo despues de que este input sea generado el gráfico se creará.


```r
observeEvent(input$generar_gráfico,{  
  
  output$frecuencia_guaguas &lt;- renderPlot({
grafico()
  })
  
  })

##### * este código es solo de ejemplo, no está completo para generar una app
```

--

Vamos al código!!!...     &lt;svg viewBox="0 0 640 512" style="height:1em;position:relative;display:inline-block;top:.1em;" xmlns="http://www.w3.org/2000/svg"&gt;  &lt;path d="M624 416H381.54c-.74 19.81-14.71 32-32.74 32H288c-18.69 0-33.02-17.47-32.77-32H16c-8.8 0-16 7.2-16 16v16c0 35.2 28.8 64 64 64h512c35.2 0 64-28.8 64-64v-16c0-8.8-7.2-16-16-16zM576 48c0-26.4-21.6-48-48-48H112C85.6 0 64 21.6 64 48v336h512V48zm-64 272H128V64h384v256z"&gt;&lt;/path&gt;&lt;/svg&gt;

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# ¿Que es la reactividad?

- Permitamos que se puedan buscar mas nombres

- y agreguemos un boton para generar un gráfico


```r
library(shiny)
library(guaguas)
library(dplyr)
library(ggplot2)

### permitimos que se busquen mas nombres ###
# selectInput(inputId = "nombre",
#             label = "Nombres",
#             choices = unique(datos$nombre),multiple = T),
# actionButton(inputId = "generar_gráfico",label = "Generar gráfico")

# datos %&gt;% 
# filter(nombre %in% c("Kevin","Bryan")) %&gt;%
#   ggplot(aes(anio,n,color=nombre)) +
#   geom_line()

### Generamos un botón que controle la generación del gráfico
# observeEvent(input$generar_gráfico,{  
#   output$frecuencia_guaguas &lt;- renderPlot({
#     grafico()
#   })
# })

### Evitamos que al cambiar nombres, se esté generando el gráfico constantemente, despues de que el botón fue generado
# isolate({grafico()})

datos &lt;- guaguas %&gt;% filter(n &gt;= 100)


ui &lt;- fluidPage(
  titlePanel("Buscando nombres"),
  sidebarLayout(
    sidebarPanel(h3("Inputs"),
                 selectInput(inputId = "nombre",
                             label = "Nombres",
                             choices = unique(datos$nombre))
    ),
    mainPanel(h3("Outputs"),
              plotOutput(outputId = "frecuencia_guaguas")
    )
  )
)

server &lt;- function(input, output, session) {
  
  grafico &lt;- reactive({datos %&gt;%
      filter(nombre == input$nombre) %&gt;%
      ggplot(aes(anio,n)) +
      geom_line()
  })
  
  output$frecuencia_guaguas &lt;- renderPlot({
    grafico()
  })
}
shinyApp(ui, server)
```

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# ¿Entonces que es la aislación?


```r
#     isolate({input$valor1})  * isolate({ input$valor2})


library(shiny)

ui &lt;- fluidPage(
  numericInput("valor1","Valor 1",value = 10),

  shiny::br(),
  shiny::br(),

  numericInput("valor2","Valor 2",value = 10),

  shiny::br(),
  shiny::br(),

  verbatimTextOutput("resultado"),

  shiny::br() ,
  shiny::br() ,


  shiny::actionButton("calc_btn","Calcular")

)

server &lt;- function(input, output, session) {

observeEvent(input$calc_btn,{
  output$resultado = renderText({

    input$valor1  *  input$valor2

  })

})



}

shinyApp(ui, server)
```

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Un ejemplo mas complejo 

--

- La siguiente shiny App genera cálculos de estadísticas publicadas por el INE, específicamente la Encuesta Nacional Urbana de Seguridad Ciudadana.

--

- Esta app aplica el [estandar](https://www.ine.gob.cl/docs/default-source/institucionalidad/buenas-pr%C3%A1cticas/clasificaciones-y-estandares/est%C3%A1ndar-evaluaci%C3%B3n-de-calidad-de-estimaciones-publicaci%C3%B3n-27022020.pdf) de calidad definido por el INE para evaluar la calidad de las estadísticas publicadas.

--

- Estos calculos se realizan utilizando el paquete de [calidad](https://cran.r-project.org/web/packages/calidad/vignettes/tutorial.html)  desarrollado en R que aplica el [estandar](https://www.ine.gob.cl/docs/default-source/institucionalidad/buenas-pr%C3%A1cticas/clasificaciones-y-estandares/est%C3%A1ndar-evaluaci%C3%B3n-de-calidad-de-estimaciones-publicaci%C3%B3n-27022020.pdf).

--

- Este paquete es un **wrapper** del paquete [survey](https://cran.r-project.org/web/packages/survey/index.html) aplicado al [estandar](https://www.ine.gob.cl/docs/default-source/institucionalidad/buenas-pr%C3%A1cticas/clasificaciones-y-estandares/est%C3%A1ndar-evaluaci%C3%B3n-de-calidad-de-estimaciones-publicaci%C3%B3n-27022020.pdf) INE.

.center[&lt;img src="imagenes/ecuacion.png" width= "300"/&gt;]

--
.pull-left[
**El es Thomas Lumley, su creador**
]

--

.pull-right[
.left[&lt;img src="imagenes/nerds.gif" width= "200"/&gt;]
]

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Un ejemplo mas complejo 

- ¿Que implica agregar un nivel de desagregación a los cálculos?


```r
#     isolate({input$valor1})  * isolate({ input$valor2})

library(shiny)
library(calidad)
library(survey)


### declaramos diseño complejo
com_dis &lt;- svydesign(ids = ~Conglomerado,
                     strata = ~VarStrat,
                     weights = ~Fact_Pers,data = enusc)

options(survey.lonely.psu = "certainty")


## APP #

### UI ####
ui &lt;- fluidPage(
  titlePanel("Probando paquete calidad del INE"),
  sidebarLayout(sidebarPanel(
    selectInput("var",label = "Variable de interés",choices = c("",names(enusc)),selected = ""),
  #  selectInput("denom",label = "Variable denominador",choices = c("",names(enusc)),selected = ""),
  #  selectInput("dominio",label = "Variable desagregacion",choices = c("",names(enusc)),selected = ""),
    downloadButton("download_tabla","Descarga")),
                mainPanel(tableOutput("tabla")
                          ))
)

### SERVER ####
server &lt;- function(input, output, session) {


  # if(input$denom == ""){
  #   R_denom =  NULL
  # }else{
  #   R_denom = input$denom
  # }
  #
  # R_dominio = reactive({
  #   # print(input$dominio)
  #
  #   if(input$dominio == ""){
  #     NULL
  #   }else{
  #     input$dominio
  #   }
  # })

### generamos tabla
  tabulado &lt;- reactive({
  calidad::assess(calidad::create_prop(var = input$var,
                #denominator = #R_denom(),
              #  domains = #R_dominio(),
                design = com_dis))
  })


  output$tabla &lt;- renderTable({
req(input$var)

    # print(R_dominio)
    # print(R_denom)

tabulado()

    })


  # output$download_tabla &lt;- downloadHandler(
  #   filename = function() {
  #     paste0("tabulado-", format(Sys.time(),"%Y-%m-%d-%H%M%S"), ".xlsx", sep="")
  #   },
  #   content = function(file) {
  #     writexl::write_xlsx(tabulado(), file)
  #   }
  # )
}

shinyApp(ui, server)
```

---

class: inverse, center, middle

# IV. Ejemplos de Shiny Apps construidas en el INE.

---

class: inverse, center, middle

# V. Tips y referencias

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Algunos tips

--

- Planificar tu app

--

- Explorar técnicas de debugging (**print()** es tu copiloto)
        
--
        
- GIT !!!

--

- Posibilidades para montar en la web una Shiny App
   - shinyapps.io
   - ShinyServer
   - Docker+Shiny o ShinyServer
   - ShinyProxy 
   
   
   .right[&lt;img src="imagenes/docker_proxy_shiny.png" width= "400"/&gt;]

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Paquetes complementarios 

- Shinytheme (ui)

--

- Leaflet (trabajo con mapas y datos georefenciados)

--

- Golem (Desarrollo de apps)

--

- Rhino (Desarrollo de apps) [https://rhinoverse.dev/#rhino](https://rhinoverse.dev/#rhino) 

--

- ShinyManager (autenticación)

--

- usar:
    - shiny::runExample(NA)
    - shiny::runExample("03_reactivity")
    - shiny::runExample("04_mpg")
    - shiny::runExample("05_sliders")
      
--

- ¿Que viene respecto a Shiny?
     - Shiny for python
     - R in the browser
 
 
---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Material utilizado para esta clase 


- https://shiny.posit.co/r/gallery/

  
  
- Libro hadley Whickam https://mastering-shiny.org
  
---

class: center, middle

.linea-superior[]
.linea-inferior[]

&lt;img src="imagenes/logo_portada2.png" width="200" /&gt;

## Capacitación en R y herramientas de productividad - Shiny

## Proyecto Estratégico Metodologías y Ciencia de Datos para la Producción Estadística

### Junio 2023
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "13:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
